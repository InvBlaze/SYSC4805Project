#define USE_LINE_SENSORS 1

// --- Line sensors configuration---
#define L A0
#define M A1
#define R A2

// --- Ultrasonic sensors LEFT & RIGHT configuration ---
#define US_LEFT_TRIG   24
#define US_LEFT_ECHO   25
#define US_RIGHT_TRIG  29
#define US_RIGHT_ECHO  27

// --- Motor pins configuration---
#define M1_PWM 2
#define M1_DIR 3
#define M2_PWM 4
#define M2_DIR 5
#define M3_PWM 6
#define M3_DIR 7
#define M4_PWM 8
#define M4_DIR 9

// Line thresholds(This may vary based on the actual measured field values)
int TH_L = 750, TH_M = 750, TH_R = 750;

// ==== Default SPEEDS ====
int BASE_SPEED       = 135;  
int AVOID_SPEED      = 255;  
int BACK_SPEED       = 255;
int TURNAROUND_SPEED = 255;

// Edge handling timings
int BACK_MS_SINGLE     = 600;  // single-side back distance
int BACK_MAX_MS_SINGLE = 900;
int BACK_MS_SHORT      = 200;  // ~1/3 of single-side distance
int BACK_MAX_MS_SHORT  = 300;
int LINE_COOLDOWN_MS   = 200;  // ignore line sensors after spin/turn

// Ultrasonic scheduling/filtering
const unsigned long US_PERIOD_MS = 60;     // per-sensor period
const unsigned long US_TO_US     = 24000;  // pulseIn timeout
const float US_ALPHA             = 0.45f;  // low-pass

// NEAR gating distance for ultrasonic
const float HIGH_NEAR_CM = 20.0f;  // detection range for obstacles

// Debounce: require N consecutive near hits
const uint8_t NEAR_CONFIRM_N = 4;
const uint8_t NEAR_DROP_N    = 2;

// Turnaround
int   TURNAROUND_TIME_MS = 1550;
const float MS_PER_DEG = TURNAROUND_TIME_MS / 180.0f;
const float SIDE_TURN_DEG = 50.0f;  // side spin angle for L-only / R-only

// -------------------- State machine --------------------
enum State {
  RUN_FORWARD,
  TURN_AROUND,
  EDGE_BACKING,
  EDGE_SPINNING,
  LINE_COOLDOWN
};
State state = RUN_FORWARD;

enum TurnDir { TURN_RIGHT, TURN_LEFT };
TurnDir plannedTurn = TURN_RIGHT;
bool lastTurnRight = true;

// How EDGE_BACKING should behave
enum EdgeBackMode { EDGE_BACK_SPIN, EDGE_BACK_SHORT_TURN };
EdgeBackMode edgeBackMode = EDGE_BACK_SPIN;

unsigned long stateStart = 0;
unsigned long cooldownStart = 0;
unsigned long sonarCooldownUntil = 0;
unsigned long spinTargetMs = 0;

// -------------------- Ultrasonic cache--------------------
float us_left_cm  = 10000.0f;
float us_right_cm = 10000.0f;
unsigned long lastPingLeft  = 0;
unsigned long lastPingRight = 0;
bool pingLeftNext = true;

uint8_t leftNearCnt  = 0, rightNearCnt = 0;
bool leftNear  = false, rightNear = false;

// -------------------- Forward decls --------------------
void forward(int s);
void backward(int s);
void turnLeft(int s);
void turnRight(int s);
void stopMotors();

// -------------------- Utilities --------------------
static inline void pulseTrig(int pin) {
  digitalWrite(pin, LOW); delayMicroseconds(2);
  digitalWrite(pin, HIGH); delayMicroseconds(10);
  digitalWrite(pin, LOW);
}
static float readUS_once(int trig, int echo) {
  pulseTrig(trig);
  unsigned long dur = pulseIn(echo, HIGH, US_TO_US);
  if (dur == 0) return 10000.0f;
  return (dur * 0.0343f) * 0.5f;
}
static float lpFilter(float prev, float newest) {
  return (1.0f - US_ALPHA) * prev + US_ALPHA * newest;
}
static inline void updateNear(bool &flag, uint8_t &cnt, bool sampleNear, uint8_t needUp, uint8_t needDown){
  if (sampleNear) { if (cnt < 255) cnt++; if (cnt >= needUp) flag = true; }
  else { if (cnt > 0) cnt--; if (cnt <= needDown) flag = false; }
}

// Read LEFT & RIGHT ultrasonics, staggered so they don't interfere
static void ultrasonicUpdate() {
  unsigned long now = millis();
  if (pingLeftNext) {
    if (now - lastPingLeft >= US_PERIOD_MS) {
      float raw = readUS_once(US_LEFT_TRIG, US_LEFT_ECHO);
      us_left_cm  = lpFilter(us_left_cm, raw);
      lastPingLeft = now;
      pingLeftNext = false;

      bool nearSample = (us_left_cm > 0.0f && us_left_cm <= HIGH_NEAR_CM);
      updateNear(leftNear, leftNearCnt, nearSample, NEAR_CONFIRM_N, NEAR_DROP_N);
    }
  } else {
    if (now - lastPingRight >= US_PERIOD_MS) {
      float raw = readUS_once(US_RIGHT_TRIG, US_RIGHT_ECHO);
      us_right_cm = lpFilter(us_right_cm, raw);
      lastPingRight = now;
      pingLeftNext = true;

      bool nearSample = (us_right_cm > 0.0f && us_right_cm <= HIGH_NEAR_CM);
      updateNear(rightNear, rightNearCnt, nearSample, NEAR_CONFIRM_N, NEAR_DROP_N);
    }
  }
}

// -------------------- Setup --------------------
void setup() {
  Serial.begin(115200);
  Serial.println("=== Snowplow (dual sonar + line edge, 1.5x speed) ===");

  pinMode(M1_PWM, OUTPUT); pinMode(M1_DIR, OUTPUT);
  pinMode(M2_PWM, OUTPUT); pinMode(M2_DIR, OUTPUT);
  pinMode(M3_PWM, OUTPUT); pinMode(M3_DIR, OUTPUT);
  pinMode(M4_PWM, OUTPUT); pinMode(M4_DIR, OUTPUT);

  pinMode(US_LEFT_TRIG,  OUTPUT);
  pinMode(US_LEFT_ECHO,  INPUT);
  pinMode(US_RIGHT_TRIG, OUTPUT);
  pinMode(US_RIGHT_ECHO, INPUT);

  // Seed sonar values
  us_left_cm  = readUS_once(US_LEFT_TRIG,  US_LEFT_ECHO);
  us_right_cm = readUS_once(US_RIGHT_TRIG, US_RIGHT_ECHO);
  leftNear    = (us_left_cm  > 0.0f && us_left_cm  <= HIGH_NEAR_CM);
  rightNear   = (us_right_cm > 0.0f && us_right_cm <= HIGH_NEAR_CM);

  stopMotors();
  delay(200);
  Serial.println("Ready");
}

// -------------------- Loop --------------------
void loop() {
  ultrasonicUpdate();

  int Lval=0, Mval=0, Rval=0;
  bool L_black=false, M_black=false, R_black=false;
#if USE_LINE_SENSORS
  Lval = analogRead(L);
  Mval = analogRead(M);
  Rval = analogRead(R);

  L_black = (Lval > TH_L);
  M_black = (Mval > TH_M);
  R_black = (Rval > TH_R);
#endif

  // ---------- Line sensor edge logic ----------
#if USE_LINE_SENSORS
  if ((L_black || M_black || R_black) &&
      !(state == EDGE_BACKING || state == EDGE_SPINNING || state == LINE_COOLDOWN || state == TURN_AROUND))
  {
    uint8_t blackCount = (L_black ? 1 : 0) + (M_black ? 1 : 0) + (R_black ? 1 : 0);

    Serial.print("[EDGE] L/M/R = ");
    Serial.print(Lval); Serial.print("/");
    Serial.print(Mval); Serial.print("/");
    Serial.println(Rval);

    // --- Multi-sensor or M-only -> short back (1/3) then TURN_AROUND ---
    if (blackCount >= 2) {
      // 2 or 3 sensors black
      plannedTurn   = lastTurnRight ? TURN_LEFT : TURN_RIGHT; // alternate
      lastTurnRight = !lastTurnRight;
      edgeBackMode  = EDGE_BACK_SHORT_TURN;

      Serial.println("  -> MULTI-SENSOR -> SHORT BACK (1/3) + TURN_AROUND");
      stopMotors(); delay(25);
      stateStart = millis();
      state      = EDGE_BACKING;
    }
    // SINGLE-SIDE: back + spin (old behaviour)
    else if (L_black) {  // here blackCount == 1, M and R are false
      plannedTurn   = TURN_RIGHT;
      lastTurnRight = true;
      edgeBackMode  = EDGE_BACK_SPIN;
      spinTargetMs  = (unsigned long)(SIDE_TURN_DEG * MS_PER_DEG);

      Serial.print("  -> LEFT ONLY -> BACK + RIGHT spin ~");
      Serial.print(SIDE_TURN_DEG);
      Serial.println("°");

      stopMotors(); delay(25);
      stateStart = millis();
      state      = EDGE_BACKING;
    }
    else if (R_black) {  // here blackCount == 1, L and M are false
      plannedTurn   = TURN_LEFT;
      lastTurnRight = false;
      edgeBackMode  = EDGE_BACK_SPIN;
      spinTargetMs  = (unsigned long)(SIDE_TURN_DEG * MS_PER_DEG);

      Serial.print("  -> RIGHT ONLY -> BACK + LEFT spin ~");
      Serial.print(SIDE_TURN_DEG);
      Serial.println("°");

      stopMotors(); delay(25);
      stateStart = millis();
      state      = EDGE_BACKING;
    }
    // M-only: short back (1/3) then TURN_AROUND
    else if (M_black) {
      plannedTurn   = lastTurnRight ? TURN_LEFT : TURN_RIGHT;
      lastTurnRight = !lastTurnRight;
      edgeBackMode  = EDGE_BACK_SHORT_TURN;

      Serial.println("  -> MIDDLE ONLY -> SHORT BACK (1/3) + TURN_AROUND");
      stopMotors(); delay(25);
      stateStart = millis();
      state      = EDGE_BACKING;
    }
  }
#endif

  // ---------- State machine ----------
  switch (state) {
    case RUN_FORWARD: {
      // Ignore sonar for a short time after backs/turns
      bool sonarArmed = (millis() >= sonarCooldownUntil);

      // LEFT or RIGHT ultrasonic near -> obstacle turn (~150°)
      if (sonarArmed && (leftNear || rightNear)) {
        Serial.print("[TURN] sonar near: L=");
        Serial.print(us_left_cm);
        Serial.print(" cm, R=");
        Serial.print(us_right_cm);
        Serial.println(" cm -> obstacle turn (~150°)");

        stopMotors(); delay(10);
        stateStart = millis();

        // Choose spin direction based on which side is near
        if (leftNear && !rightNear) {
          plannedTurn   = TURN_RIGHT;
          lastTurnRight = true;
        } else if (rightNear && !leftNear) {
          plannedTurn   = TURN_LEFT;
          lastTurnRight = false;
        } else {  // both near -> alternate
          plannedTurn   = lastTurnRight ? TURN_LEFT : TURN_RIGHT;
          lastTurnRight = !lastTurnRight;
        }

        state = TURN_AROUND;
        break;
      }

      forward(BASE_SPEED);
      break;
    }

    case TURN_AROUND: {
      if (plannedTurn == TURN_LEFT) turnLeft(TURNAROUND_SPEED);
      else                          turnRight(TURNAROUND_SPEED);

      // Use 150° turn
      if (millis() - stateStart >= (unsigned long)(TURNAROUND_TIME_MS * 150L / 180L)) {
        stopMotors(); delay(15);
        state = RUN_FORWARD;
        sonarCooldownUntil = millis() + 300;
        Serial.println("TURN_AROUND (~150°) done -> RUN");
      }
      break;
    }

    case EDGE_BACKING: {
      // Back up; duration depends on edgeBackMode
      backward(BACK_SPEED);
      unsigned long dt = millis() - stateStart;

      int backMsTarget;
      int backMaxTarget;

      if (edgeBackMode == EDGE_BACK_SPIN) {
        backMsTarget  = BACK_MS_SINGLE;
        backMaxTarget = BACK_MAX_MS_SINGLE;
      } else { // EDGE_BACK_SHORT_TURN
        backMsTarget  = BACK_MS_SHORT;
        backMaxTarget = BACK_MAX_MS_SHORT;
      }

      if (dt >= (unsigned long)backMsTarget || dt >= (unsigned long)backMaxTarget) {
        stopMotors(); delay(30);

        if (edgeBackMode == EDGE_BACK_SPIN) {
          // Single-side: full back, then spin
          stateStart = millis();
          state      = EDGE_SPINNING;
          Serial.println("Backed from single-side edge -> SPIN");
        } else {
          // Center / multi: short back, then TURN_AROUND
          stateStart = millis();
          state      = TURN_AROUND;
          Serial.println("Short back from center/multi -> TURN_AROUND");
        }
      }
      break;
    }

    case EDGE_SPINNING: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long dt = millis() - stateStart;
      if (dt >= spinTargetMs) {
        stopMotors();
        cooldownStart      = millis();
        state              = LINE_COOLDOWN;
        sonarCooldownUntil = millis() + 300;
        Serial.print("SPIN done (");
        Serial.print(dt);
        Serial.println(" ms) -> COOLDOWN");
      }
      break;
    }

    case LINE_COOLDOWN: {
      // Drive forward a bit while ignoring line sensors to avoid immediate retrigger
      forward(BASE_SPEED);
      if (millis() - cooldownStart >= (unsigned long)LINE_COOLDOWN_MS) {
        state = RUN_FORWARD;
        Serial.println("COOLDOWN -> RUN");
      }
      break;
    }
  }

  delay(5);
}

// -------------------- Motor helpers --------------------
void forward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void backward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnLeft(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnRight(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void stopMotors() {
  analogWrite(M1_PWM, 0);
  analogWrite(M3_PWM, 0);
  analogWrite(M2_PWM, 0);
  analogWrite(M4_PWM, 0);
}
