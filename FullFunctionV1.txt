// === Feature toggles ===
#define USE_LINE_SENSORS 1    // 1: use L/M/R on A0..A2; 0: ignore line sensors
#define USE_IMU         1    // 1: enable LSM6DS33 over I2C for yaw hold + closed-loop turns

#include <Wire.h>

// === Line sensors (front) ===
#define L A0
#define M A1
#define R A2

// === Ultrasonic sensors (front, low & high) ===
#define US_LOW_TRIG   22
#define US_LOW_ECHO   23
#define US_HIGH_TRIG  24
#define US_HIGH_ECHO  25

// === Motor pins (unchanged) ===
#define M1_PWM 2
#define M1_DIR 3
#define M2_PWM 4
#define M2_DIR 5
#define M3_PWM 6
#define M3_DIR 7
#define M4_PWM 8
#define M4_DIR 9

// === Thresholds / tuning ===
int TH_L = 900, TH_M = 900, TH_R = 900;     // tape thresholds

// SPEEDS (doubled cruise + faster edge recovery)
int BASE_SPEED   = 180;   // normal cruising (was 90)
int PUSH_SPEED   = 80;    // push cube gently
int AVOID_SPEED  = 180;   // spin speed when avoiding
int BACK_SPEED   = 200;   // strong back-out from edge

// Edge handling timings
int BACK_MAX_MS  = 700;   // cap for backing
int CLEAR_DWELL  = 200;   // must be off tape for this long
int SPIN_MIN_MS  = 850;   // min spin
int SPIN_MAX_MS  = 1400;  // max spin
int LINE_COOLDOWN_MS = 350; // ignore tape after spin

// Ultrasonic cadence
const unsigned long US_PERIOD_MS = 60;    // per-sensor ping period (staggered)
const unsigned long US_TO_US     = 24000; // pulseIn timeout (µs)

// Ultrasonic classification windows (tune to mount geometry)
float LOW_RMIN  = 8.0f,  LOW_RMAX  = 30.0f;   // low sonar window (plow zone)
float HIGH_RMIN = 10.0f, HIGH_RMAX = 250.0f;  // high sonar window

// --- Obstacle turnaround feature ---
float OBSTACLE_TURNAROUND_CM = 15.0f;  // trigger distance for 180° spin
int   TURNAROUND_SPEED       = 180;    // speed during turnaround
int   TURNAROUND_TIME_MS     = 1100;   // fallback time for 180° (kept as guard)

// === IMU (LSM6DS33) config ===
#if USE_IMU
// I2C addresses (try 0x6B first, else 0x6A)
#define LSM6_ADDR_PRIMARY 0x6B
#define LSM6_ADDR_ALT     0x6A

// Registers
#define LSM6_REG_WHOAMI  0x0F
#define LSM6_WHOAMI_VAL  0x69
#define LSM6_CTRL1_XL    0x10
#define LSM6_CTRL2_G     0x11
#define LSM6_CTRL3_C     0x12
#define LSM6_OUTX_L_G    0x22  // X,Y,Z gyro start (little-endian)

// Gyro scale = 245 dps ⇒ 8.75 mdps/LSB
const float GYRO_DPS_PER_LSB = 0.00875f;

// Yaw hold + closed-loop spins
float YAW_KP = 2.0f;      // PWM per degree of yaw error (tune 1.0–3.0)
int   YAW_MAX_TRIM = 60;  // max +/- PWM trim
float EDGE_SPIN_TARGET_DEG = 90.0f;   // desired edge-escape spin angle
float TURN_AROUND_TARGET_DEG = 180.0f;// desired 180° turn

// IMU runtime vars
uint8_t LSM6_ADDR = LSM6_ADDR_PRIMARY;
bool imu_ok = false;
float gyroBiasZ_dps = 0.0f;
unsigned long imuLastMicros = 0;
volatile float yaw_deg = 0.0f;      // integrated yaw
float heading_target_deg = 0.0f;    // straight-line target
bool heading_target_set = false;

// Spin tracking
float spin_start_yaw = 0.0f;

// I2C helpers
void i2cWrite8(uint8_t addr, uint8_t reg, uint8_t val) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  Wire.write(val);
  Wire.endTransmission(true);
}
bool i2cReadBytes(uint8_t addr, uint8_t reg, uint8_t n, uint8_t* buf) {
  Wire.beginTransmission(addr);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) return false;
  if (Wire.requestFrom(addr, n) != n) return false;
  for (uint8_t i=0;i<n;i++) buf[i]=Wire.read();
  return true;
}
float wrapTo180(float a){
  while(a>180.0f) a-=360.0f;
  while(a<-180.0f) a+=360.0f;
  return a;
}
float angleDiffDeg(float a, float b){ // returns a-b wrapped to [-180,180]
  return wrapTo180(a - b);
}
bool imu_begin() {
  Wire.begin(); // Due: uses SDA/SCL (3.3 V)
  // Probe primary
  uint8_t who=0;
  if (i2cReadBytes(LSM6_ADDR_PRIMARY, LSM6_REG_WHOAMI, 1, &who) && who==LSM6_WHOAMI_VAL){
    LSM6_ADDR = LSM6_ADDR_PRIMARY;
  } else if (i2cReadBytes(LSM6_ADDR_ALT, LSM6_REG_WHOAMI, 1, &who) && who==LSM6_WHOAMI_VAL){
    LSM6_ADDR = LSM6_ADDR_ALT;
  } else {
    return false;
  }
  // Enable auto-increment + BDU
  i2cWrite8(LSM6_ADDR, LSM6_CTRL3_C, 0x44); // IF_INC=1, BDU=1
  // 104 Hz accel & gyro, 2g and 245 dps
  i2cWrite8(LSM6_ADDR, LSM6_CTRL1_XL, 0x40); // ODR_XL=104 Hz
  i2cWrite8(LSM6_ADDR, LSM6_CTRL2_G,  0x40); // ODR_G =104 Hz, FS_G=245 dps
  delay(50);
  return true;
}
bool imu_readGyroZ_raw(int16_t &gz_raw){
  uint8_t buf[6];
  if(!i2cReadBytes(LSM6_ADDR, LSM6_OUTX_L_G, 6, buf)) return false;
  int16_t gx = (int16_t)(buf[1]<<8 | buf[0]);
  int16_t gy = (int16_t)(buf[3]<<8 | buf[2]);
  int16_t gz = (int16_t)(buf[5]<<8 | buf[4]);
  (void)gx; (void)gy;
  gz_raw = gz;
  return true;
}
void imu_calibrate_bias(){ // assume stationary
  const int N=400;
  long acc=0;
  int16_t gz=0;
  for(int i=0;i<N;i++){
    if(imu_readGyroZ_raw(gz)) acc += gz;
    delay(3);
  }
  float rawBias = (float)acc/N;
  gyroBiasZ_dps = rawBias * GYRO_DPS_PER_LSB;
}
void imu_update(){
  if(!imu_ok) return;
  int16_t gz_raw=0;
  if(!imu_readGyroZ_raw(gz_raw)) return;
  unsigned long now = micros();
  if(imuLastMicros==0) { imuLastMicros = now; return; }
  float dt = (now - imuLastMicros) * 1e-6f;
  imuLastMicros = now;
  float gz_dps = gz_raw * GYRO_DPS_PER_LSB - gyroBiasZ_dps;
  yaw_deg = wrapTo180(yaw_deg + gz_dps * dt);
}
#endif // USE_IMU

// === State machine ===
enum State {
  RUN_FORWARD,
  EDGE_BACKING,
  EDGE_SPINNING,
  LINE_COOLDOWN,
  PUSH_CUBE,
  AVOID_OBSTACLE,
  TURN_AROUND
};
State state = RUN_FORWARD;

enum TurnDir { TURN_RIGHT, TURN_LEFT, TURN_DEFAULT };
TurnDir plannedTurn = TURN_DEFAULT;

unsigned long stateStart = 0;
unsigned long cooldownStart = 0;

// === Ultrasonic cache/scheduling ===
float us_low_cm  = 10000.0f;
float us_high_cm = 10000.0f;
unsigned long lastPingLow  = 0;
unsigned long lastPingHigh = 0;
bool pingLowNext = true;

// === Forward declarations of motor helpers ===
void forward(int s);
void backward(int s);
void turnLeft(int s);
void turnRight(int s);
void stopMotors();

// NEW: differential forward (for yaw hold)
void forwardLR(int leftPWM, int rightPWM);

// === Utilities ===
static inline void pulseTrig(int pin) {
  digitalWrite(pin, LOW); delayMicroseconds(2);
  digitalWrite(pin, HIGH); delayMicroseconds(10);
  digitalWrite(pin, LOW);
}
static float readUltrasonicCM(int trig, int echo) {
  pulseTrig(trig);
  unsigned long dur = pulseIn(echo, HIGH, US_TO_US);
  if (dur == 0) return 10000.0f;           // timeout → no target
  return (dur * 0.0343f) * 0.5f;           // cm
}
static void staggeredUltrasonicUpdate() {
  unsigned long now = millis();
  if (pingLowNext) {
    if (now - lastPingLow >= US_PERIOD_MS) {
      us_low_cm = readUltrasonicCM(US_LOW_TRIG, US_LOW_ECHO);
      lastPingLow = now;
      pingLowNext = false;
    }
  } else {
    if (now - lastPingHigh >= US_PERIOD_MS) {
      us_high_cm = readUltrasonicCM(US_HIGH_TRIG, US_HIGH_ECHO);
      lastPingHigh = now;
      pingLowNext = true;
    }
  }
}

// --- Ahead classifier (no typedef; avoids Arduino auto-prototype issue) ---
enum { AHEAD_CLEAR, AHEAD_CUBE, AHEAD_TALL };  // integer labels

int classifyAhead() {
  bool low_hit  = (us_low_cm  >= LOW_RMIN  && us_low_cm  <= LOW_RMAX);
  bool high_hit = (us_high_cm >= HIGH_RMIN && us_high_cm <= HIGH_RMAX);
  if (low_hit && !high_hit) return AHEAD_CUBE;  // ~20 mm cube (snow)
  if (high_hit)             return AHEAD_TALL;  // tall obstacle/wall/robot
  return AHEAD_CLEAR;
}

void setup() {
  Serial.begin(115200);
  Serial.println("=== Snowplow: 2x Ultrasonic + 15cm Turnaround + IMU Yaw Hold ===");

  pinMode(M1_PWM, OUTPUT); pinMode(M1_DIR, OUTPUT);
  pinMode(M2_PWM, OUTPUT); pinMode(M2_DIR, OUTPUT);
  pinMode(M3_PWM, OUTPUT); pinMode(M3_DIR, OUTPUT);
  pinMode(M4_PWM, OUTPUT); pinMode(M4_DIR, OUTPUT);

  pinMode(US_LOW_TRIG, OUTPUT);
  pinMode(US_LOW_ECHO, INPUT);
  pinMode(US_HIGH_TRIG, OUTPUT);
  pinMode(US_HIGH_ECHO, INPUT);

#if USE_IMU
  imu_ok = imu_begin();
  if (imu_ok) {
    Serial.println("IMU OK, calibrating gyro bias...");
    imu_calibrate_bias();
    imuLastMicros = micros();
    yaw_deg = 0.0f;
    Serial.println("IMU ready.");
  } else {
    Serial.println("IMU NOT FOUND (running without yaw features).");
  }
#endif

  stopMotors();
  delay(300);
  Serial.println("Ready");
}

void loop() {
#if USE_IMU
  imu_update();
#endif

  // Update sonars
  staggeredUltrasonicUpdate();
  int ahead = classifyAhead();

  // Read tape sensors (if enabled)
  int Lval=0, Mval=0, Rval=0;
  bool L_black=false, M_black=false, R_black=false;
#if USE_LINE_SENSORS
  Lval = analogRead(L);
  Mval = analogRead(M);
  Rval = analogRead(R);
  L_black = (Lval > TH_L);
  M_black = (Mval > TH_M);
  R_black = (Rval > TH_R);
#endif

  switch (state) {
    case RUN_FORWARD: {
#if USE_IMU
      // Capture a straight-line heading when we (re)enter RUN_FORWARD
      if (!heading_target_set && imu_ok) {
        heading_target_deg = yaw_deg;
        heading_target_set = true;
        // Serial.print("Heading target set: "); Serial.println(heading_target_deg);
      }
#endif

#if USE_LINE_SENSORS
      if (L_black || M_black || R_black) {
        if (L_black && !R_black) plannedTurn = TURN_RIGHT;
        else if (R_black && !L_black) plannedTurn = TURN_LEFT;
        else plannedTurn = TURN_RIGHT;

        Serial.print("[EDGE] L="); Serial.print(Lval);
        Serial.print(" M="); Serial.print(Mval);
        Serial.print(" R="); Serial.println(Rval);

        stopMotors(); delay(50);
        stateStart = millis();
#if USE_IMU
        spin_start_yaw = yaw_deg;
        heading_target_set = false; // we'll reacquire after escape
#endif
        state = EDGE_BACKING;
        break;
      }
#endif

      // 15 cm turnaround for tall obstacles (both sensors hit)
      bool low_hit  = (us_low_cm  >= LOW_RMIN  && us_low_cm  <= LOW_RMAX);
      bool high_hit = (us_high_cm >= HIGH_RMIN && us_high_cm <= HIGH_RMAX);
      bool both_hit = (low_hit && high_hit);
      bool very_close = ( (us_low_cm  <= OBSTACLE_TURNAROUND_CM) ||
                          (us_high_cm <= OBSTACLE_TURNAROUND_CM) );

      if (both_hit && very_close) {
        stopMotors(); delay(20);
        stateStart = millis();
#if USE_IMU
        spin_start_yaw = yaw_deg;
        heading_target_set = false;
#endif
        state = TURN_AROUND;
        Serial.print("[AHEAD] BOTH<=15cm -> TURN_AROUND  low=");
        Serial.print(us_low_cm); Serial.print(" high=");
        Serial.println(us_high_cm);
        break;
      }

      // Normal classification-based behavior
      if (ahead == AHEAD_TALL) {
        stopMotors(); delay(20);
        stateStart = millis();
        plannedTurn = TURN_RIGHT; // or alternate
#if USE_IMU
        spin_start_yaw = yaw_deg;
        heading_target_set = false;
#endif
        state = AVOID_OBSTACLE;
        Serial.println("[AHEAD] TALL -> AVOID");
        break;
      } else if (ahead == AHEAD_CUBE) {
        state = PUSH_CUBE;
        Serial.println("[AHEAD] CUBE -> PUSH");
        break;
      }

      // Forward with yaw hold (if IMU OK), else plain forward
#if USE_IMU
      if (imu_ok) {
        float err = angleDiffDeg(heading_target_deg, yaw_deg);
        int trim = (int)(YAW_KP * err);
        if (trim >  YAW_MAX_TRIM) trim =  YAW_MAX_TRIM;
        if (trim < -YAW_MAX_TRIM) trim = -YAW_MAX_TRIM;
        forwardLR(BASE_SPEED + trim, BASE_SPEED - trim);
      } else
#endif
      {
        forward(BASE_SPEED);
      }
      break;
    }

    case PUSH_CUBE: {
      // Keep pushing straight with yaw hold if available
      if (classifyAhead() == AHEAD_CUBE) {
#if USE_IMU
        if (imu_ok) {
          float err = angleDiffDeg(heading_target_deg, yaw_deg);
          int trim = (int)(YAW_KP * err);
          if (trim >  YAW_MAX_TRIM) trim =  YAW_MAX_TRIM;
          if (trim < -YAW_MAX_TRIM) trim = -YAW_MAX_TRIM;
          forwardLR(PUSH_SPEED + trim, PUSH_SPEED - trim);
        } else
#endif
        {
          forward(PUSH_SPEED);
        }
      } else {
        heading_target_set = false; // will reacquire when back to RUN_FORWARD
        state = RUN_FORWARD;
      }
      break;
    }

    case AVOID_OBSTACLE: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long t = millis() - stateStart;
      bool canStop = (t >= 500);
      bool timeout = (t >= 1200);

#if USE_IMU
      // Closed-loop angle stop if IMU OK and min time satisfied
      bool angleReached = false;
      if (imu_ok && canStop) {
        float d = fabs(angleDiffDeg(yaw_deg, spin_start_yaw));
        angleReached = (d >= EDGE_SPIN_TARGET_DEG);
      }
      if ((canStop && (classifyAhead() == AHEAD_CLEAR || angleReached)) || timeout) {
#else
      if ((canStop && classifyAhead() == AHEAD_CLEAR) || timeout) {
#endif
        stopMotors(); delay(30);
        state = RUN_FORWARD;
        Serial.println("AVOID done -> RUN");
      }
      break;
    }

    case TURN_AROUND: {
      // Timed + angle-based 180° spin
      turnRight(TURNAROUND_SPEED);
      unsigned long t = millis() - stateStart;
      bool timeOK = (t >= (unsigned long)TURNAROUND_TIME_MS); // fallback guard

#if USE_IMU
      bool angleOK = false;
      if (imu_ok) {
        float d = fabs(angleDiffDeg(yaw_deg, spin_start_yaw));
        angleOK = (d >= (TURN_AROUND_TARGET_DEG - 5.0f)); // small tolerance
      }
      if (timeOK || angleOK) {
#else
      if (timeOK) {
#endif
        stopMotors(); delay(30);
        heading_target_set = false; // reacquire straight heading
        state = RUN_FORWARD;
        Serial.println("TURN_AROUND done -> RUN");
      }
      break;
    }

    case EDGE_BACKING: {
      static unsigned long clearSince = 0;
      backward(BACK_SPEED);

#if USE_LINE_SENSORS
      bool anyBlack = (L_black || M_black || R_black);
      if (!anyBlack) {
        if (clearSince == 0) clearSince = millis();
        if (millis() - clearSince >= (unsigned long)CLEAR_DWELL) {
          stopMotors(); delay(50);
          stateStart = millis();
#if USE_IMU
          spin_start_yaw = yaw_deg;
#endif
          state = EDGE_SPINNING;
          clearSince = 0;
          Serial.println("Back clear -> SPIN");
        }
      } else {
        clearSince = 0;
      }
#else
      if (millis() - stateStart >= (unsigned long)BACK_MAX_MS) {
        stopMotors(); delay(50);
        stateStart = millis();
#if USE_IMU
        spin_start_yaw = yaw_deg;
#endif
        state = EDGE_SPINNING;
      }
#endif
      if (millis() - stateStart >= (unsigned long)BACK_MAX_MS) {
        stopMotors(); delay(50);
        stateStart = millis();
#if USE_IMU
        spin_start_yaw = yaw_deg;
#endif
        state = EDGE_SPINNING;
        Serial.println("Back max -> SPIN");
      }
      break;
    }

    case EDGE_SPINNING: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long dt = millis() - stateStart;
      bool canFinish  = (dt >= (unsigned long)SPIN_MIN_MS);
      bool mustFinish = (dt >= (unsigned long)SPIN_MAX_MS);

#if USE_IMU
      bool angleOK = false;
      if (imu_ok) {
        float d = fabs(angleDiffDeg(yaw_deg, spin_start_yaw));
        angleOK = (d >= EDGE_SPIN_TARGET_DEG);
      }
      if (mustFinish || (canFinish && (classifyAhead() == AHEAD_CLEAR || angleOK))) {
#else
      if (mustFinish || (canFinish && classifyAhead() == AHEAD_CLEAR)) {
#endif
        stopMotors();
        cooldownStart = millis();
        heading_target_set = false;
        state = LINE_COOLDOWN;
        Serial.println("SPIN -> COOLDOWN");
      }
      break;
    }

    case LINE_COOLDOWN: {
      // short ignore window for tape; reacquire heading next RUN_FORWARD entry
#if USE_IMU
      heading_target_set = false;
#endif
      forward(BASE_SPEED);
      if (millis() - cooldownStart >= (unsigned long)LINE_COOLDOWN_MS) {
        state = RUN_FORWARD;
        Serial.println("COOLDOWN -> RUN");
      }
      break;
    }
  }

  delay(5);
}

// === Motor helpers (with PWM clamp) ===
void forward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);   // left side forward
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);  // right side forward
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void forwardLR(int leftPWM, int rightPWM) {
  int Ls = constrain(leftPWM,  0, 255);
  int Rs = constrain(rightPWM, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);   // left forward
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);  // right forward
  analogWrite(M1_PWM, Ls);
  analogWrite(M3_PWM, Ls);
  analogWrite(M2_PWM, Rs);
  analogWrite(M4_PWM, Rs);
}
void backward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnLeft(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnRight(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void stopMotors() {
  analogWrite(M1_PWM, 0);
  analogWrite(M3_PWM, 0);
  analogWrite(M2_PWM, 0);
  analogWrite(M4_PWM, 0);
}