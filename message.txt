

// === Feature toggles ===
#define USE_LINE_SENSORS 1    // 1: use L/M/R on A0..A2; 0: ignore line sensors

// === Line sensors (front) ===
#define L A0
#define M A1
#define R A2

// === Ultrasonic sensors (front, low & high) ===
#define US_LOW_TRIG   22
#define US_LOW_ECHO   23
#define US_HIGH_TRIG  24
#define US_HIGH_ECHO  25

// === Motor pins (unchanged) ===
#define M1_PWM 2
#define M1_DIR 3
#define M2_PWM 4
#define M2_DIR 5
#define M3_PWM 6
#define M3_DIR 7
#define M4_PWM 8
#define M4_DIR 9

// === Thresholds / tuning ===
// === Thresholds / tuning ===
int TH_L = 900, TH_M = 900, TH_R = 900;     // tape thresholds

// SPEEDS
int BASE_SPEED   = 180;   // was 90 → doubled (normal cruising)
int PUSH_SPEED   = 80;    // keep gentle when pushing cubes (raise if you want)
int AVOID_SPEED  = 180;   // was 80 → faster spin when avoiding obstacles/edge
int BACK_SPEED   = 200;   // was 100 → stronger back-out from edge

int BACK_MAX_MS  = 700;   // timings unchanged
int CLEAR_DWELL  = 200;
int SPIN_MIN_MS  = 850;
int SPIN_MAX_MS  = 1400;
int LINE_COOLDOWN_MS = 350;


const unsigned long US_PERIOD_MS = 60;   // per-sensor ping period (staggered)
const unsigned long US_TO_US     = 24000; // pulseIn timeout (µs)

float LOW_RMIN  = 8.0f,  LOW_RMAX  = 30.0f;   // low sonar window
float HIGH_RMIN = 10.0f, HIGH_RMAX = 250.0f;  // high sonar window

// === State machine ===
enum State {
  RUN_FORWARD,
  EDGE_BACKING,
  EDGE_SPINNING,
  LINE_COOLDOWN,
  PUSH_CUBE,
  AVOID_OBSTACLE
};
State state = RUN_FORWARD;

enum TurnDir { TURN_RIGHT, TURN_LEFT, TURN_DEFAULT };
TurnDir plannedTurn = TURN_DEFAULT;

unsigned long stateStart = 0;
unsigned long cooldownStart = 0;

// === Ultrasonic cache/scheduling ===
float us_low_cm  = 10000.0f;
float us_high_cm = 10000.0f;
unsigned long lastPingLow  = 0;
unsigned long lastPingHigh = 0;
bool pingLowNext = true;

// === Forward declarations of motor helpers (Arduino can auto-prototype, but be explicit) ===
void forward(int s);
void backward(int s);
void turnLeft(int s);
void turnRight(int s);
void stopMotors();

// === Utilities ===
static inline void pulseTrig(int pin) {
  digitalWrite(pin, LOW); delayMicroseconds(2);
  digitalWrite(pin, HIGH); delayMicroseconds(10);
  digitalWrite(pin, LOW);
}
static float readUltrasonicCM(int trig, int echo) {
  pulseTrig(trig);
  unsigned long dur = pulseIn(echo, HIGH, US_TO_US);
  if (dur == 0) return 10000.0f;           // timeout → no target
  return (dur * 0.0343f) * 0.5f;           // cm
}
static void staggeredUltrasonicUpdate() {
  unsigned long now = millis();
  if (pingLowNext) {
    if (now - lastPingLow >= US_PERIOD_MS) {
      us_low_cm = readUltrasonicCM(US_LOW_TRIG, US_LOW_ECHO);
      lastPingLow = now;
      pingLowNext = false;
    }
  } else {
    if (now - lastPingHigh >= US_PERIOD_MS) {
      us_high_cm = readUltrasonicCM(US_HIGH_TRIG, US_HIGH_ECHO);
      lastPingHigh = now;
      pingLowNext = true;
    }
  }
}

// === Define the classifier type BEFORE using it (this fixes your error) ===
// --- Ahead classifier (no typedef; avoids Arduino auto-prototype issue) ---
enum { AHEAD_CLEAR, AHEAD_CUBE, AHEAD_TALL };  // integer labels

int classifyAhead() {
  bool low_hit  = (us_low_cm  >= LOW_RMIN  && us_low_cm  <= LOW_RMAX);
  bool high_hit = (us_high_cm >= HIGH_RMIN && us_high_cm <= HIGH_RMAX);
  if (low_hit && !high_hit) return AHEAD_CUBE;  // ~20 mm cube
  if (high_hit)             return AHEAD_TALL;  // wall/robot/box
  return AHEAD_CLEAR;
}

void setup() {
  Serial.begin(115200);
  Serial.println("=== Snowplow: 2x Ultrasonic + Robust Edge Escape ===");

  pinMode(M1_PWM, OUTPUT); pinMode(M1_DIR, OUTPUT);
  pinMode(M2_PWM, OUTPUT); pinMode(M2_DIR, OUTPUT);
  pinMode(M3_PWM, OUTPUT); pinMode(M3_DIR, OUTPUT);
  pinMode(M4_PWM, OUTPUT); pinMode(M4_DIR, OUTPUT);

  pinMode(US_LOW_TRIG, OUTPUT);
  pinMode(US_LOW_ECHO, INPUT);
  pinMode(US_HIGH_TRIG, OUTPUT);
  pinMode(US_HIGH_ECHO, INPUT);

  stopMotors();
  delay(300);
  Serial.println("Ready");
}

void loop() {
  // Update sonars
  staggeredUltrasonicUpdate();
  int ahead = classifyAhead();

  // Read tape sensors (if enabled)
  int Lval=0, Mval=0, Rval=0;
  bool L_black=false, M_black=false, R_black=false;
#if USE_LINE_SENSORS
  Lval = analogRead(L);
  Mval = analogRead(M);
  Rval = analogRead(R);
  L_black = (Lval > TH_L);
  M_black = (Mval > TH_M);
  R_black = (Rval > TH_R);
#endif

  switch (state) {
    case RUN_FORWARD: {
#if USE_LINE_SENSORS
      if (L_black || M_black || R_black) {
        // decide spin direction
        if (L_black && !R_black) plannedTurn = TURN_RIGHT;
        else if (R_black && !L_black) plannedTurn = TURN_LEFT;
        else plannedTurn = TURN_RIGHT;

        Serial.print("[EDGE] L="); Serial.print(Lval);
        Serial.print(" M="); Serial.print(Mval);
        Serial.print(" R="); Serial.println(Rval);

        stopMotors(); delay(50);
        stateStart = millis();
        state = EDGE_BACKING;
        break;
      }
#endif
      if (ahead == AHEAD_TALL) {
        stopMotors(); delay(20);
        stateStart = millis();
        plannedTurn = TURN_RIGHT; // or alternate for variety
        state = AVOID_OBSTACLE;
        Serial.println("[AHEAD] TALL -> AVOID");
        break;
      } else if (ahead == AHEAD_CUBE) {
        state = PUSH_CUBE;
        Serial.println("[AHEAD] CUBE -> PUSH");
        break;
      }
      forward(BASE_SPEED);
      break;
    }

    case PUSH_CUBE: {
      if (classifyAhead() == AHEAD_CUBE) {
        forward(PUSH_SPEED);
      } else {
        state = RUN_FORWARD;
      }
      break;
    }

    case AVOID_OBSTACLE: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long t = millis() - stateStart;
      if (t >= 500) {
        if (classifyAhead() == AHEAD_CLEAR || t >= 1200) {
          stopMotors(); delay(30);
          state = RUN_FORWARD;
          Serial.println("AVOID done -> RUN");
        }
      }
      break;
    }

    case EDGE_BACKING: {
      static unsigned long clearSince = 0;
      backward(BACK_SPEED);

#if USE_LINE_SENSORS
      bool anyBlack = (L_black || M_black || R_black);
      if (!anyBlack) {
        if (clearSince == 0) clearSince = millis();
        if (millis() - clearSince >= (unsigned long)CLEAR_DWELL) {
          stopMotors(); delay(50);
          stateStart = millis();
          state = EDGE_SPINNING;
          clearSince = 0;
          Serial.println("Back clear -> SPIN");
        }
      } else {
        clearSince = 0;
      }
#else
      if (millis() - stateStart >= (unsigned long)BACK_MAX_MS) {
        stopMotors(); delay(50);
        stateStart = millis();
        state = EDGE_SPINNING;
      }
#endif
      if (millis() - stateStart >= (unsigned long)BACK_MAX_MS) {
        stopMotors(); delay(50);
        stateStart = millis();
        state = EDGE_SPINNING;
        Serial.println("Back max -> SPIN");
      }
      break;
    }

    case EDGE_SPINNING: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long dt = millis() - stateStart;
      bool canFinish  = (dt >= (unsigned long)SPIN_MIN_MS);
      bool mustFinish = (dt >= (unsigned long)SPIN_MAX_MS);

      if (mustFinish || (canFinish && classifyAhead() == AHEAD_CLEAR)) {
        stopMotors();
        cooldownStart = millis();
        state = LINE_COOLDOWN;
        Serial.println("SPIN -> COOLDOWN");
      }
      break;
    }

    case LINE_COOLDOWN: {
      forward(BASE_SPEED);
      if (millis() - cooldownStart >= (unsigned long)LINE_COOLDOWN_MS) {
        state = RUN_FORWARD;
        Serial.println("COOLDOWN -> RUN");
      }
      break;
    }
  }

  delay(5);
}

// === Motor helpers ===
// === Motor helpers ===
void forward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void backward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnLeft(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnRight(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}

void stopMotors() {
  analogWrite(M1_PWM, 0);
  analogWrite(M3_PWM, 0);
  analogWrite(M2_PWM, 0);
  analogWrite(M4_PWM, 0);
}
