// ========================== CONFIG / PINS ==========================
#define USE_LINE_SENSORS 1

// --- Line sensors (front) ---
#define L A0
#define M A1
#define R A2

// --- Ultrasonic sensors (front, low & high) ---
#define US_LOW_TRIG   22
#define US_LOW_ECHO   23
#define US_HIGH_TRIG  24
#define US_HIGH_ECHO  25

// --- Motor pins (unchanged) ---
#define M1_PWM 2
#define M1_DIR 3
#define M2_PWM 4
#define M2_DIR 5
#define M3_PWM 6
#define M3_DIR 7
#define M4_PWM 8
#define M4_DIR 9

// --- Speeds / Timings ---
int BASE_SPEED   = 160;  // cruise
int PUSH_SPEED   = 90;   // gentle push for cubes
int AVOID_SPEED  = 180;  // obstacle/edge spin
int BACK_SPEED   = 200;  // strong back-out

// Edge handling timings (ms)
int BACK_MS          = 500;   // back straight at least this long
int BACK_MAX_MS      = 900;   // hard cap on backing
int SPIN_MIN_MS      = 700;   // min spin to clear edge (shorter; we now steer by side)
int SPIN_MAX_MS      = 1200;  // hard cap on spin
int LINE_COOLDOWN_MS = 200;   // ignore line sensors after spin

// Ultrasonic scheduling/filtering
const unsigned long US_PERIOD_MS = 60;     // per-sensor period (staggered)
const unsigned long US_TO_US     = 24000;  // pulseIn timeout (μs)
const float US_ALPHA             = 0.45f;  // low-pass (0..1)

// === NEAR gating distances (cm) ===
const float LOW_NEAR_CM  = 10.0f;  // cube (low sensor)
const float HIGH_NEAR_CM = 20.0f;  // tall obstacle (high sensor)

// Debounce: require N consecutive near hits
const uint8_t NEAR_CONFIRM_N = 4;
const uint8_t NEAR_DROP_N    = 2;

// Turnaround (~180°)
int   TURNAROUND_SPEED   = 180;
int   TURNAROUND_TIME_MS = 1100;   // ~180° (tune ±100)

// ================== ROBUST LINE DETECTION (CAL + FILTER) ===================
// Calibration over floor (white) at startup
const unsigned long LINE_CAL_MS = 1200;  // 1.2s baseline
const int   MARGIN_MIN = 40;             // sensitivity (lower -> more sensitive)
const int   MARGIN_MAX = 120;            // cap
const int   HYST_BAND  = 15;             // hysteresis band (ADC counts)
const unsigned HIT_PERSIST_MS = 20;      // need ~20ms consistency
const unsigned LINE_REARM_MS   = 120;    // must see white this long to re-arm

int BASE_ADC[3] = {750,750,750};         // learned floor baselines: L/M/R
int MARGIN[3]   = {60,60,60};            // per-sensor delta from baseline

// 3-sample median buffers
int bidx=0, bufL[3]={0,0,0}, bufM[3]={0,0,0}, bufR[3]={0,0,0};
inline int med3(int a,int b,int c){ if(a>b){int t=a;a=b;b=t;} if(b>c){int t=b;b=c;c=t;} if(a>b){int t=a;a=b;b=t;} return b; }

// hysteresis state
bool L_hit0=false, M_hit0=false, R_hit0=false;
unsigned long lineHitStart = 0, whiteStartMs = 0;
bool lineArmed = true;

// ====================== STATE MACHINE ==============================
enum State {
  RUN_FORWARD,
  PUSH_CUBE,
  AVOID_OBSTACLE,
  TURN_AROUND,
  EDGE_BACKING,
  EDGE_SPINNING,
  LINE_COOLDOWN
};
State state = RUN_FORWARD;

enum TurnDir { TURN_RIGHT, TURN_LEFT };
TurnDir plannedTurn = TURN_RIGHT;
bool lastTurnRight = true;

unsigned long stateStart = 0;
unsigned long cooldownStart = 0;
unsigned long sonarCooldownUntil = 0;

// ==================== ULTRASONIC CACHE =============================
float us_low_cm  = 10000.0f;
float us_high_cm = 10000.0f;
unsigned long lastPingLow  = 0;
unsigned long lastPingHigh = 0;
bool pingLowNext = true;

uint8_t lowNearCnt = 0, highNearCnt = 0;
bool lowNear = false, highNear = false;

// ======================= FORWARD DECLS =============================
void forward(int s);
void backward(int s);
void turnLeft(int s);
void turnRight(int s);
void stopMotors();

// =========================== UTILITIES =============================
static inline void pulseTrig(int pin) {
  digitalWrite(pin, LOW); delayMicroseconds(2);
  digitalWrite(pin, HIGH); delayMicroseconds(10);
  digitalWrite(pin, LOW);
}
static float readUS_once(int trig, int echo) {
  pulseTrig(trig);
  unsigned long dur = pulseIn(echo, HIGH, US_TO_US);
  if (dur == 0) return 10000.0f;          // timeout -> far
  return (dur * 0.0343f) * 0.5f;          // us->cm / round trip
}
static float lpFilter(float prev, float newest) {
  return (1.0f - US_ALPHA) * prev + US_ALPHA * newest;
}
static inline void updateNear(bool &flag, uint8_t &cnt, bool sampleNear, uint8_t needUp, uint8_t needDown){
  if (sampleNear) { if (cnt < 255) cnt++; if (cnt >= needUp) flag = true; }
  else { if (cnt > 0) cnt--; if (cnt <= needDown) flag = false; }
}
static void ultrasonicUpdate() {
  unsigned long now = millis();
  if (pingLowNext) {
    if (now - lastPingLow >= US_PERIOD_MS) {
      float raw = readUS_once(US_LOW_TRIG, US_LOW_ECHO);
      us_low_cm  = lpFilter(us_low_cm, raw);
      lastPingLow = now;
      pingLowNext = false;

      bool nearSample = (us_low_cm > 0.0f && us_low_cm <= LOW_NEAR_CM);
      updateNear(lowNear, lowNearCnt, nearSample, NEAR_CONFIRM_N, NEAR_DROP_N);
    }
  } else {
    if (now - lastPingHigh >= US_PERIOD_MS) {
      float raw = readUS_once(US_HIGH_TRIG, US_HIGH_ECHO);
      us_high_cm = lpFilter(us_high_cm, raw);
      lastPingHigh = now;
      pingLowNext = true;

      bool nearSample = (us_high_cm > 0.0f && us_high_cm <= HIGH_NEAR_CM);
      updateNear(highNear, highNearCnt, nearSample, NEAR_CONFIRM_N, NEAR_DROP_N);
    }
  }
}
static inline bool bothVeryClose(){
  return (us_low_cm  <= 10.0f) &&
         (us_high_cm <= 20.0f) &&
         lowNear && highNear;
}

// ============================ SETUP ================================
void setup() {
  Serial.begin(115200);
  Serial.println("=== Snowplow (side-based edge turning + robust line) ===");

  pinMode(M1_PWM, OUTPUT); pinMode(M1_DIR, OUTPUT);
  pinMode(M2_PWM, OUTPUT); pinMode(M2_DIR, OUTPUT);
  pinMode(M3_PWM, OUTPUT); pinMode(M3_DIR, OUTPUT);
  pinMode(M4_PWM, OUTPUT); pinMode(M4_DIR, OUTPUT);

  pinMode(US_LOW_TRIG, OUTPUT);
  pinMode(US_LOW_ECHO, INPUT);
  pinMode(US_HIGH_TRIG, OUTPUT);
  pinMode(US_HIGH_ECHO, INPUT);

  // Seed sonar values
  us_low_cm  = readUS_once(US_LOW_TRIG,  US_LOW_ECHO);
  us_high_cm = readUS_once(US_HIGH_TRIG, US_HIGH_ECHO);
  lowNear  = (us_low_cm  > 0.0f && us_low_cm  <= LOW_NEAR_CM);
  highNear = (us_high_cm > 0.0f && us_high_cm <= HIGH_NEAR_CM);

  stopMotors();
  delay(200);

#if USE_LINE_SENSORS
  // ---- Calibrate line baselines (white floor) ----
  Serial.println("[LINE] Calibrating floor baseline ~1.2s...");
  unsigned long t0 = millis();
  long sumL=0, sumM=0, sumR=0; int n=0;
  while (millis() - t0 < LINE_CAL_MS) {
    sumL += analogRead(L);
    sumM += analogRead(M);
    sumR += analogRead(R);
    n++; delay(4);
  }
  if (n>0) {
    BASE_ADC[0] = (int)(sumL / n);
    BASE_ADC[1] = (int)(sumM / n);
    BASE_ADC[2] = (int)(sumR / n);
  }
  // conservative margins (~8% of 10-bit span), clamped
  for (int i=0;i<3;i++) {
    int mg = (int)(0.08f * 1023.0f);
    MARGIN[i] = constrain(mg, MARGIN_MIN, MARGIN_MAX);
  }
  // prime median buffers
  int L0 = analogRead(L), M0 = analogRead(M), R0 = analogRead(R);
  bufL[0]=bufL[1]=bufL[2]=L0;
  bufM[0]=bufM[1]=bufM[2]=M0;
  bufR[0]=bufR[1]=bufR[2]=R0;

  Serial.print("[LINE] BASE L/M/R = ");
  Serial.print(BASE_ADC[0]); Serial.print("/");
  Serial.print(BASE_ADC[1]); Serial.print("/");
  Serial.println(BASE_ADC[2]);
  Serial.print("[LINE] MARGIN L/M/R = ");
  Serial.print(MARGIN[0]); Serial.print("/");
  Serial.print(MARGIN[1]); Serial.print("/");
  Serial.println(MARGIN[2]);
#endif

  Serial.println("Ready");
}

// ============================= LOOP ================================
void loop() {
  ultrasonicUpdate();

  // -------- Robust Line Sensing (filtered, hysteretic, persisted) --------
  bool anyHit = false;
  int  dL=0, dM=0, dR=0;  // deviations for debug

#if USE_LINE_SENSORS
  // Read & filter (median of 3)
  int rL = analogRead(L), rM = analogRead(M), rR = analogRead(R);
  bufL[bidx]=rL; bufM[bidx]=rM; bufR[bidx]=rR; bidx=(bidx+1)%3;
  int Lf = med3(bufL[0],bufL[1],bufL[2]);
  int Mf = med3(bufM[0],bufM[1],bufM[2]);
  int Rf = med3(bufR[0],bufR[1],bufR[2]);

  // Deviation from floor (polarity-agnostic)
  dL = abs(Lf - BASE_ADC[0]);
  dM = abs(Mf - BASE_ADC[1]);
  dR = abs(Rf - BASE_ADC[2]);

  // Hysteretic per-sensor hit
  auto hitH = [](int dev, int thr, bool prev)->bool {
    int up = thr + HYST_BAND;
    int dn = thr - HYST_BAND;
    return prev ? (dev >= dn) : (dev >= up);
  };
  bool L_hit = hitH(dL, MARGIN[0], L_hit0);
  bool M_hit = hitH(dM, MARGIN[1], M_hit0);
  bool R_hit = hitH(dR, MARGIN[2], R_hit0);
  L_hit0 = L_hit; M_hit0 = M_hit; R_hit0 = R_hit;

  anyHit = (L_hit || M_hit || R_hit);

  // Persistence + re-arm logic
  unsigned long now = millis();
  if (!anyHit) { // white region
    if (whiteStartMs==0) whiteStartMs = now;
    if (!lineArmed && (now - whiteStartMs >= LINE_REARM_MS)) lineArmed = true;
    lineHitStart = 0;
  } else {       // something changed (likely tape)
    whiteStartMs = 0;
    if (lineHitStart==0) lineHitStart = now;
  }

  bool lineConfirmed = anyHit && (lineHitStart!=0) && (millis() - lineHitStart >= HIT_PERSIST_MS);
  if (lineArmed && lineConfirmed &&
      !(state == EDGE_BACKING || state == EDGE_SPINNING || state == LINE_COOLDOWN))
  {
    // --------- SIDE-BASED TURN DECISION ---------
    // Left sees black -> turn RIGHT
    // Right sees black -> turn LEFT
    // Middle or ambiguous -> alternate
    if (L_hit && !R_hit) {
      plannedTurn = TURN_RIGHT;
    } else if (R_hit && !L_hit) {
      plannedTurn = TURN_LEFT;
    } else {
      // tie / only middle / both: alternate to escape
      plannedTurn = lastTurnRight ? TURN_LEFT : TURN_RIGHT;
      lastTurnRight = !lastTurnRight;
    }

    Serial.print("[EDGE] dev L/M/R = ");
    Serial.print(dL); Serial.print("/");
    Serial.print(dM); Serial.print("/");
    Serial.println(dR);

    stopMotors(); delay(25);
    stateStart   = millis();
    state        = EDGE_BACKING;
    lineArmed    = false;               // need some white before next trigger
    whiteStartMs = 0;
  }
#endif

  // --------------------- MAIN STATE MACHINE ------------------------
  switch (state) {
    case RUN_FORWARD: {
      bool sonarArmed = (millis() >= sonarCooldownUntil);

      if (sonarArmed && bothVeryClose()) {
        Serial.println("[TURN] both near & very close -> 180°");
        stopMotors(); delay(10);
        stateStart = millis();
        // alternate direction on each 180°
        plannedTurn = lastTurnRight ? TURN_LEFT : TURN_RIGHT;
        lastTurnRight = !lastTurnRight;
        state = TURN_AROUND;
        break;
      }

      if (sonarArmed && highNear) {
        stopMotors(); delay(10);
        stateStart = millis();
        plannedTurn = lastTurnRight ? TURN_LEFT : TURN_RIGHT;
        lastTurnRight = !lastTurnRight;
        state = AVOID_OBSTACLE;
        Serial.println("[AHEAD] TALL (near) -> AVOID");
        break;
      }
      if (sonarArmed && lowNear && !highNear) {
        state = PUSH_CUBE;
        Serial.println("[AHEAD] CUBE (near) -> PUSH");
        break;
      }

      forward(BASE_SPEED);
      break;
    }

    case PUSH_CUBE: {
      if (lowNear && !highNear) {
        forward(PUSH_SPEED);
      } else {
        stopMotors(); delay(10);
        state = RUN_FORWARD;
        sonarCooldownUntil = millis() + 250;
        Serial.println("PUSH done -> RUN");
      }
      break;
    }

    case AVOID_OBSTACLE: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long t = millis() - stateStart;
      if (!highNear || t >= 1200) {
        stopMotors(); delay(15);
        state = RUN_FORWARD;
        sonarCooldownUntil = millis() + 300;
        Serial.println("AVOID done -> RUN");
      }
      break;
    }

    case TURN_AROUND: {
      if (plannedTurn == TURN_LEFT) turnLeft(TURNAROUND_SPEED);
      else                          turnRight(TURNAROUND_SPEED);
      if (millis() - stateStart >= (unsigned long)TURNAROUND_TIME_MS) {
        stopMotors(); delay(15);
        state = RUN_FORWARD;
        sonarCooldownUntil = millis() + 300;
        Serial.println("TURN_AROUND done -> RUN");
      }
      break;
    }

    case EDGE_BACKING: {
      backward(BACK_SPEED);
      unsigned long dt = millis() - stateStart;
      if (dt >= (unsigned long)BACK_MS || dt >= (unsigned long)BACK_MAX_MS) {
        stopMotors(); delay(30);
        stateStart = millis();
        state = EDGE_SPINNING;
        Serial.println("Backed -> SPIN");
      }
      break;
    }

    case EDGE_SPINNING: {
      if (plannedTurn == TURN_LEFT) turnLeft(AVOID_SPEED);
      else                          turnRight(AVOID_SPEED);

      unsigned long dt = millis() - stateStart;
      bool canFinish  = (dt >= (unsigned long)SPIN_MIN_MS);
      bool mustFinish = (dt >= (unsigned long)SPIN_MAX_MS);
      if (mustFinish || canFinish) {
        stopMotors();
        cooldownStart = millis();
        state = LINE_COOLDOWN;
        sonarCooldownUntil = millis() + 300;
        Serial.println("SPIN -> COOLDOWN");
      }
      break;
    }

    case LINE_COOLDOWN: {
      forward(BASE_SPEED);
      if (millis() - cooldownStart >= (unsigned long)LINE_COOLDOWN_MS) {
        state = RUN_FORWARD;
        Serial.println("COOLDOWN -> RUN");
      }
      break;
    }
  }

  delay(5);
}

// ======================== MOTOR HELPERS ============================
void forward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void backward(int s) {
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnLeft(int s) {  // left back, right forward
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, HIGH);
  digitalWrite(M3_DIR, HIGH);
  digitalWrite(M2_DIR, HIGH);
  digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void turnRight(int s) { // left forward, right back
  s = constrain(s, 0, 255);
  digitalWrite(M1_DIR, LOW);
  digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, LOW);
  digitalWrite(M4_DIR, LOW);
  analogWrite(M1_PWM, s);
  analogWrite(M3_PWM, s);
  analogWrite(M2_PWM, s);
  analogWrite(M4_PWM, s);
}
void stopMotors() {
  analogWrite(M1_PWM, 0);
  analogWrite(M3_PWM, 0);
  analogWrite(M2_PWM, 0);
  analogWrite(M4_PWM, 0);
}
