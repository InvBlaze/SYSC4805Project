// ====== Toggle which tests to run ======
#define RUN_TEST_IMU        1
#define RUN_TEST_LINE       1
#define RUN_TEST_ULTRASONIC 1
#define RUN_TEST_MOTORS     1
#define RUN_TEST_SPEEDLIMIT 0  // set 1 only if you have encoders + speed_cm_per_s()

// ====== Pins (same as your Code V1) ======
#include <Wire.h>
#define L A0
#define M A1
#define R A2
#define US_LOW_TRIG   22
#define US_LOW_ECHO   23
#define US_HIGH_TRIG  24
#define US_HIGH_ECHO  25
#define M1_PWM 2
#define M1_DIR 3
#define M2_PWM 4
#define M2_DIR 5
#define M3_PWM 6
#define M3_DIR 7
#define M4_PWM 8
#define M4_DIR 9

// ====== Helpers ======
struct TR { const char* name; bool pass; const char* note; };
#define ASSERT_OK(cond, msg) do{ if(!(cond)){ Serial.println(String("[FAIL] ")+msg); ok=false; } }while(0)
void print_header(const char* n){ Serial.println("\n===== UNIT TEST: "+String(n)+" ====="); }
void print_summary(const char* n, bool ok){ Serial.println(String("[SUMMARY] ")+n+" -> "+(ok?"PASS":"FAIL")); }
void wait_key(const char* msg){ Serial.println(msg); while(Serial.available()) Serial.read(); while(!Serial.available()){} while(Serial.available()) Serial.read(); }
long ms(){ return (long)millis(); }

// ====== Motor helpers (safe clamp) ======
void stopMotors(){ analogWrite(M1_PWM,0); analogWrite(M3_PWM,0); analogWrite(M2_PWM,0); analogWrite(M4_PWM,0); }
void forwardLR(int Lp,int Rp){
  Lp = constrain(Lp,0,255); Rp = constrain(Rp,0,255);
  digitalWrite(M1_DIR, LOW); digitalWrite(M3_DIR, LOW);
  digitalWrite(M2_DIR, HIGH); digitalWrite(M4_DIR, HIGH);
  analogWrite(M1_PWM,Lp); analogWrite(M3_PWM,Lp); analogWrite(M2_PWM,Rp); analogWrite(M4_PWM,Rp);
}
void backward(int s){
  s = constrain(s,0,255);
  digitalWrite(M1_DIR,HIGH); digitalWrite(M3_DIR,HIGH);
  digitalWrite(M2_DIR,LOW);  digitalWrite(M4_DIR,LOW);
  analogWrite(M1_PWM,s); analogWrite(M3_PWM,s); analogWrite(M2_PWM,s); analogWrite(M4_PWM,s);
}
void turnRight(int s){
  s = constrain(s,0,255);
  digitalWrite(M1_DIR,LOW); digitalWrite(M3_DIR,LOW);
  digitalWrite(M2_DIR,LOW); digitalWrite(M4_DIR,LOW);
  analogWrite(M1_PWM,s); analogWrite(M3_PWM,s); analogWrite(M2_PWM,s); analogWrite(M4_PWM,s);
}

// ====== Ultrasonic (same cadence as V1) ======
const unsigned long US_PERIOD_MS=60, US_TO_US=24000;
float us_low_cm=1e6, us_high_cm=1e6; unsigned long lastLow=0,lastHigh=0; bool pingLow=true;
static inline void pulseTrig(int pin){ digitalWrite(pin,LOW); delayMicroseconds(2); digitalWrite(pin,HIGH); delayMicroseconds(10); digitalWrite(pin,LOW); }
static float readUS(int trig,int echo){ pulseTrig(trig); unsigned long d=pulseIn(echo,HIGH,US_TO_US); return d? (d*0.0343f*0.5f):1e6; }
void us_update(){
  unsigned long now=millis();
  if(pingLow){ if(now-lastLow>=US_PERIOD_MS){ us_low_cm=readUS(US_LOW_TRIG,US_LOW_ECHO); lastLow=now; pingLow=false; } }
  else { if(now-lastHigh>=US_PERIOD_MS){ us_high_cm=readUS(US_HIGH_TRIG,US_HIGH_ECHO); lastHigh=now; pingLow=true; } }
}
float LOW_RMIN=8,LOW_RMAX=30, HIGH_RMIN=10,HIGH_RMAX=250;

// ====== IMU (LSM6DS33 minimal: gyro Z yaw) ======
#if RUN_TEST_IMU
#define LSM6_ADDR_PRIMARY 0x6B
#define LSM6_ADDR_ALT     0x6A
#define LSM6_REG_WHOAMI   0x0F
#define LSM6_WHOAMI_VAL   0x69
#define LSM6_CTRL1_XL     0x10
#define LSM6_CTRL2_G      0x11
#define LSM6_CTRL3_C      0x12
#define LSM6_OUTX_L_G     0x22
float YAW_KP=2.0, yaw_deg=0, gyroBiasZ_dps=0; unsigned long imu_us=0; uint8_t IMU_ADDR=LSM6_ADDR_PRIMARY; bool imu_ok=false;
const float GYRO_DPS_PER_LSB=0.00875f;
bool i2cRead(uint8_t a,uint8_t r,uint8_t n,uint8_t*b){ Wire.beginTransmission(a); Wire.write(r); if(Wire.endTransmission(false)) return false; if(Wire.requestFrom(a,n)!=n) return false; for(uint8_t i=0;i<n;i++) b[i]=Wire.read(); return true; }
void i2cWrite8(uint8_t a,uint8_t r,uint8_t v){ Wire.beginTransmission(a); Wire.write(r); Wire.write(v); Wire.endTransmission(true); }
bool imu_begin(){
  Wire.begin();
  uint8_t who=0;
  if(i2cRead(LSM6_ADDR_PRIMARY,LSM6_REG_WHOAMI,1,&who) && who==LSM6_WHOAMI_VAL) IMU_ADDR=LSM6_ADDR_PRIMARY;
  else if(i2cRead(LSM6_ADDR_ALT,LSM6_REG_WHOAMI,1,&who) && who==LSM6_WHOAMI_VAL) IMU_ADDR=LSM6_ADDR_ALT;
  else return false;
  i2cWrite8(IMU_ADDR,LSM6_CTRL3_C,0x44); // BDU+auto-increment
  i2cWrite8(IMU_ADDR,LSM6_CTRL1_XL,0x40); // 104Hz accel
  i2cWrite8(IMU_ADDR,LSM6_CTRL2_G, 0x40); // 104Hz gyro 245dps
  delay(50); return true;
}
bool imu_read_gz_raw(int16_t& gz){
  uint8_t b[6]; if(!i2cRead(IMU_ADDR,LSM6_OUTX_L_G,6,b)) return false;
  gz=(int16_t)(b[5]<<8 | b[4]); return true;
}
void imu_calib(){
  const int N=400; long acc=0; int16_t gz=0;
  for(int i=0;i<N;i++){ if(imu_read_gz_raw(gz)) acc+=gz; delay(3); }
  gyroBiasZ_dps = (acc/(float)N)*GYRO_DPS_PER_LSB;
}
void imu_update(){
  if(!imu_ok) return;
  int16_t gz=0; if(!imu_read_gz_raw(gz)) return;
  unsigned long now=micros(); if(!imu_us){ imu_us=now; return; }
  float dt=(now-imu_us)*1e-6f; imu_us=now;
  float gz_dps=gz*GYRO_DPS_PER_LSB - gyroBiasZ_dps;
  yaw_deg += gz_dps*dt;
  // wrap:
  if(yaw_deg>180) yaw_deg-=360; else if(yaw_deg<-180) yaw_deg+=360;
}
#endif

// ====== SPEED LIMIT support (stub unless you implement encoders) ======
#if RUN_TEST_SPEEDLIMIT
volatile long encTicksL=0, encTicksR=0; // TODO: attach interrupts for your encoders
float wheel_circ_cm = 21.0; // example 67mm dia wheel → change to yours
float ticks_per_rev = 20.0; // change to your encoder
float speed_cm_per_s(){
  static long lastTicks=0; static unsigned long lastT=0;
  unsigned long now=millis(); long ticks=(encTicksL+encTicksR)/2;
  if(!lastT){ lastT=now; lastTicks=ticks; return 0; }
  float dt=(now-lastT)/1000.0f; float drev=(ticks-lastTicks)/ticks_per_rev;
  lastT=now; lastTicks=ticks; return (drev*wheel_circ_cm)/dt;
}
int applySpeedGovernor(int desiredPWM, float v){
  static float integ=0; const float LIMIT=30.0, Kp=4.0, Ki=0.5;
  float err= LIMIT - v; integ = constrain(integ + Ki*err, -50, 50);
  return constrain(desiredPWM + (int)(Kp*err + integ), 0, 255);
}
#endif

// ====== TESTS ======
bool testIMU(){
#if RUN_TEST_IMU
  print_header("IMU");
  bool ok=true;
  imu_ok = imu_begin();
  ASSERT_OK(imu_ok,"WHO_AM_I failed");
  if(!imu_ok){ print_summary("IMU",false); return false; }
  Serial.println("Keep robot still… calibrating (1.2s)");
  imu_calib();
  unsigned long t0=millis(); int n=0; float sum=0;
  while(millis()-t0<1000){ imu_update(); delay(5); n++; sum+=yaw_deg; }
  float avg_yaw=sum/n;
  ASSERT_OK(fabs(avg_yaw)<2.0,"yaw drift too large at rest");
  Serial.println("Slowly rotate ~90 deg now…");
  wait_key("Press ENTER after rotating ~90 deg.");
  float start=yaw_deg; t0=millis(); while(millis()-t0<400){ imu_update(); delay(5); }
  float d=fabs(yaw_deg - start);
  Serial.print("Measured yaw change: "); Serial.println(d);
  ASSERT_OK(d>70 && d<110,"yaw step not ~90±20");
  print_summary("IMU",ok); return ok;
#else
  Serial.println("IMU test disabled."); return true;
#endif
}

bool testLine(){
#if RUN_TEST_LINE
  print_header("Line Sensor");
  bool ok=true; const int N=200;
  wait_key("Place sensor over WHITE, press ENTER");
  long WL=0,WM=0,WR=0; for(int i=0;i<N;i++){ WL+=analogRead(L); WM+=analogRead(M); WR+=analogRead(R); delay(2);}
  wait_key("Place sensor over BLACK tape, press ENTER");
  long BL=0,BM=0,BR=0; for(int i=0;i<N;i++){ BL+=analogRead(L); BM+=analogRead(M); BR+=analogRead(R); delay(2);}
  int meanWL=WL/N, meanWM=WM/N, meanWR=WR/N;
  int meanBL=BL/N, meanBM=BM/N, meanBR=BR/N;
  int sepL=meanBL-meanWL, sepM=meanBM-meanWM, sepR=meanBR-meanWR;
  Serial.print("ΔADC L/M/R = "); Serial.print(sepL); Serial.print("/"); Serial.print(sepM); Serial.print("/"); Serial.println(sepR);
  ASSERT_OK(sepL>150,"L separation <150");
  ASSERT_OK(sepM>150,"M separation <150");
  ASSERT_OK(sepR>150,"R separation <150");
  print_summary("Line Sensor",ok); return ok;
#else
  Serial.println("Line test disabled."); return true;
#endif
}

bool testUltrasonic(){
#if RUN_TEST_ULTRASONIC
  print_header("Ultrasonic (dual)");
  bool ok=true; unsigned long t0=millis(); int samples=0;
  while(millis()-t0<3000){ us_update(); delay(5); if(samples%10==0){ Serial.print("low="); Serial.print(us_low_cm,1); Serial.print(" cm  high="); Serial.println(us_high_cm,1);} samples++; }
  ASSERT_OK(samples>40,"update rate too low");
  // Classification quick-check
  bool low_hit=(us_low_cm>=LOW_RMIN && us_low_cm<=LOW_RMAX);
  bool high_hit=(us_high_cm>=HIGH_RMIN && us_high_cm<=HIGH_RMAX);
  Serial.print("hits: low="); Serial.print(low_hit); Serial.print(" high="); Serial.println(high_hit);
  print_summary("Ultrasonic",ok); return ok;
#else
  Serial.println("Ultrasonic test disabled."); return true;
#endif
}

bool testMotors(){
#if RUN_TEST_MOTORS
  print_header("Motors (CAUTION: wheels off ground)");
  bool ok=true;
  Serial.println("Left forward…");   forwardLR(120,  0); delay(1000); stopMotors(); delay(300);
  Serial.println("Right forward…");  forwardLR(  0,120); delay(1000); stopMotors(); delay(300);
  Serial.println("Both forward…");   forwardLR(120,120); delay(1000); stopMotors(); delay(300);
  Serial.println("Backward…");       backward(120);      delay(1000); stopMotors();
  print_summary("Motors",ok); return ok;
#else
  Serial.println("Motors test disabled."); return true;
#endif
}

bool testSpeedLimit(){
#if RUN_TEST_SPEEDLIMIT
  print_header("Speed Limit (≤30 cm/s)");
  bool ok=true; unsigned long t0=millis();
  while(millis()-t0<8000){
    float v=speed_cm_per_s();
    int pwm=applySpeedGovernor(220, v);
    forwardLR(pwm,pwm);
    Serial.print(ms()); Serial.print(",pwm="); Serial.print(pwm); Serial.print(",v="); Serial.println(v);
    delay(100);
  }
  stopMotors();
  Serial.println("Export these rows to CSV and check ≤30 cm/s compliance.");
  print_summary("Speed Limit",ok); return ok;
#else
  Serial.println("Speed-limit test disabled (no encoders)."); return true;
#endif
}

// ====== Setup/Loop ======
void setup(){
  Serial.begin(115200);
  pinMode(M1_PWM,OUTPUT); pinMode(M1_DIR,OUTPUT);
  pinMode(M2_PWM,OUTPUT); pinMode(M2_DIR,OUTPUT);
  pinMode(M3_PWM,OUTPUT); pinMode(M3_DIR,OUTPUT);
  pinMode(M4_PWM,OUTPUT); pinMode(M4_DIR,OUTPUT);
  pinMode(US_LOW_TRIG,OUTPUT); pinMode(US_LOW_ECHO,INPUT);
  pinMode(US_HIGH_TRIG,OUTPUT); pinMode(US_HIGH_ECHO,INPUT);
  stopMotors(); delay(300);
  Serial.println("== Unit Test Harness Ready @115200 ==");
}

void loop(){
  bool allpass=true;
  if(!testIMU())        allpass=false;
  if(!testLine())       allpass=false;
  if(!testUltrasonic()) allpass=false;
  if(!testMotors())     allpass=false;
  if(!testSpeedLimit()) allpass=false;

  Serial.println(String("\n=== OVERALL: ")+(allpass?"PASS":"CHECK FAILURES")+" ===");
  Serial.println("Reset the board or toggle RUN_TEST_* flags to re-run specific tests.");
  while(true){ stopMotors(); delay(250); } // halt
}
